[ Java 기초 ｜ 2021.11.02 ]

  변수 <-> 상수
  variable <-> constant

_________________________________________________________________________


[ 상수 ]
  1. constant : 값을 한번만 할당할 수 있는 공간
  2. literal : 그 자체로 값을 의미하는 것


  ▶ final을 붙히면 상수!
     ex) final int val = 100;
         -> constant >> val 이 해당됨.
         -> literal >> 100 이 해당됨.

_________________________________________________________________________


[ 논리형 ] 
  ▶ boolean (불린)
     참과 거짓을 나타내는 숫자 1과 0만을 이용하는 방식
     여기에 들어가는 리터럴은 >> false, ture

     Octo- heXa-

     int, short, long int : 정수형 / 1, 123, 0b0101, 077, 0x1F, 100L

                       ▶ 10진수(DEC) : 0~9 베이스디짓
                       ▶ 2진수(BIN) : 0,1 베이스디짓
                       ▶ 8진수(OCT) : 0~7 베이스디짓
                       ▶ 16진수(HEX) : 0~15 베이스디짓
                       ------------------------------------------
                       ▶▶ 16진수를 가장 많이 쓴다.

                       ▷ 0b0101 : (2진수) 0101 10진수로는 5에 해당
                       ▷ 077 : (8진수) 앞에 0이 오토켓 >> 77
                       ▷ 0x1F : (16진수) 1F
                       ▷ 100L : (long인티저) 100정수

  ▶▶ 정수형의 기본은 int

  ▶ float, double : 실수형 / 3.14, 10f, 3.0e8
  ▶▶ 실수형의 기본은 double
     ex) 3.14 = 0.314 x 10+1 (10의 1승) === 0.314e1 (e는 지수)

      ex) float f;
          f = 3.14f;
          f가 float을 의미하는데 이게 뭐냐면
          3.141592535.... 이렇게 소숫점이 끝이 없으면 몇번째자리인지 메모리 세야해서
          f로 끊어준다.



  ▶ char : 단일글자형, 단일문자형 / '1', 'A' (A는 65번), '\n' 
  ▶ String : 문자열 / "abc def", "true"

   System.out.print("제 20회 JAVA 클라우드 개강 \n 대용량 DB설계 \n") >> \n (개행엔터 글자다.)
   ▷ 제 20회 JAVA 클라우드 개강
      대용량 DB설계

_________________________________________________________________________

[ 산술연산자 : + ]
[ 문자열 결합 연산자 : + ]

  a + b;

  String name = "ja" + "va";  >> java
  String str = name + 8.0;  >> java8.0

  sum += i;  <<두개가 같은거임>>  sum = sum + i;
  ▷ 참조 : Day4 > Ex09반복문For_3합계

___________________________________________________________________________________________________________________

[ 기본형 vs 참조형 ]

  ▶ 기본형(Primitive type) 
     ▷ boolean, char, 정수형(byte, short, int, long), 실수형(float, double)

        ------------------------------------------------------------
        │       │   1byte   │   2bytes   │   4bytes   │   8bytes   │
        │       │  (=8bits) │  (=16bits) │  (=32bits) │  (=64bits) │
        ------------------------------------------------------------
        │ 논리형 │  boolean  │            │            │            │
        │ 문자형 │           │    char    │            │            │
        │ 정수형 │   byte    │   short    │    int     │    long    │
        │ 실수형 │           │            │   float    │   double   │
        ------------------------------------------------------------
         ※ char은 2byte다. 자바에서는 유니코드 기반이기 때문이다.
         ※ int ▶▶ 가장 전체의 기본형
         ※ double ▶ 실수형의 기본형

        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          구분  │   기본 타입   │    메모리 사용크기    │             선언 방법                │                                            저장가능한 값 범위                                                                           
        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          정수  │     byte     │     1byte (8bit)     │     byte b = 100;                   │  -2ⁿ(7승) ~ -2ⁿ(7승)-1   (-128 ~ 127)                                                                                                                             
                │     short    │     2byte (16bit)    │    short s = 100;                   │  -2ⁿ(15승) ~ 2ⁿ(15승)-1  (-32,768 ~ 32,767)                                                                         
                │     int      │     4byte (32bit)    │     int i = 100;                    │  -2ⁿ(31승) ~ 2ⁿ(31승)-1  (-2,147,483,648 ~ 2,147,483,647) 이십억, 10자리                                             
                │     long     │     8byte (64bit)    │    long 1 = 100L; (L을 붙힘)        │   -2ⁿ(63승) ~ 2ⁿ(63승)-1  (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807) 19자리                             
        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          실수  │    float     │     4byte (32bit)    │  float 1 = 10.234F; (f / F 를 붙힘)  │  (+/-)1.4E-45 ~ (+/-)3.4028235E38 (소숫점 X → 최대크기 39자릿수 / 소숫점 O → 최소크기 소수점아래 45자리)                 
                │    double    │     8byte (64bit)    │    double d = 10.234;               │  (+/-)4.9E-324 ~ (+/-)1.7976931348623157E308 (소숫점 X → 최대크기 309자릿수 / 소숫점 O → 최소크기 소수점아래 325자리)    
        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          논리  │    boolean   │     1byte (8bit)     │     boolean is = false;             │   true, false                                                                                                         
        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          문자  │     char     │     2byte (16bit)    │     char c = 'A';                   │  0 ~ 2ⁿ(16승)-1  (유니코드 \u0000 ~ \uFFFF,  0 ~ 65,571)   (아스키코드 'A' 64 / 'B' 65 / 'a' 97 / 'b' 98 / '0' 48 / '1' 49)    
        ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

          ※ 실수형 float, double 의 메모리 사용은 int, long 과 같지만,
             부동소수점 방식으로 저장되어 더 큰 범위의 값을 저장할 수 있다.

         --------------------------------------------------------------------------------------------------

         < 자동 타입 변환 >
           : 작은 크기 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.
             ▶ 큰 크기 타입 = 작은 크기 타입
             ____________________________________________________________________________

             ● 타입별 크기 순서 (byte)
               byte (1) << short (2) << int (4) << long (8) << float (4) << double (8) 
             ____________________________________________________________________________
               ※ float은 표현범위가 더 크기 때문에 더 큰 타입으로 들어간다.

               ex)
               byte B = 10;
               int A = B;   // 자동 타입 변환으로 B는 int형으로 변환된다.
                               (가지고 있는 값 10은 변하지 않음)

               int A = 20;
               double C = A; // 20.0
                                (실수 타입으로 변환하면 .0이 붙은 실수값이 된다.)

               char D = 'A';
               int A = D;    // 65 저장됨
                                (char타입이 int타입으로 변환되면 유니코드 값이 저장된다.)
               
               ※ 단, 음수가 저장될 수 있는 byte, int등의 타입은 char타입으로 자동타입 변환 할 수 없다!!!
               byte B = 65;
               char C = B;        // 컴파일 에러!!
               char D = (char)B;  // 강제 타입 변환은 가능하다!!

         --------------------------------------------------------------------------------------------------

         < 강제 타입 변환 (Casting) >
           : 큰 크기 타입은 작은 타입으로 자동 타입 변환을 할 수 없다.
             하지만 강제로 int 타입의 1byte를 잘라서 byte 타입 변수에 저장할 수 있다. (나머지 3byte는 버려짐)

             강제 타입 변환에서 사용자로부터 받은 입력값을 변환할 때 
             "값의 손실이 일어나지 않도록" 주의 해야한다.
             따라서 값이 보존할 수 있는지 체크할 필요가 있다.

             ▷ 자바에서 데이터 값 검사를 위해 해당 타입의 최대값, 최소값 상수를 제공한다.
                ● 최대값 상수 : 해당형.MAX_VALUE
                ● 최소값 상수 : 해당형.MIN_VALUE
                  https://kephilab.tistory.com/27?category=394374


             ▶ 작은 크기 타입 = (작은 크기 타입)큰 크기 타입

             ex) 
             int A = 103029770; // 00000110 00100100 00011100 "00001010" (10이 저장됨)
             byte B = (byte)A;  // 강제 타입 변환 
             ▷ 원래 값은 보존되지 못한다. (따옴표한 비트들만 저장되기 때문!!)
                만약 A가 1byte 크기 내의 값을 가진다면, 값은 보존된다.

             int A = 'A';       // 65 저장(아스키코드)(앞에 int니까 문자가 아니라 숫자로 나옴)
             char C = (char)A;  // 65에 해당되는 유니코드 문자가 저장된다.

             double B = 3.14;
             int A = (int)B;    // A는 B의 정수부분인 3만 저장된다.
             ▷ 실수 타입(float, double)은 정수 타입으로 자동 타입 변환되지 않기 때문에 
                강제 타입 변환을 사용해야 한다.
                소수점 이하 부분은 버려지고 (값 손실), 정수 부분만 저장된다.

         --------------------------------------------------------------------------------------------------

        < 연산식에서의 자동타입 변환과 강제 타입 변환 >
          : 서로 다른 타입의 피연산자가 있을 경우 두 연산자 중 크기가 큰 타입으로 자동타입 변환된 후 연산을 수행
             ____________________________________________________________________________

             ● 연산 시 자동 타입 변환 정리
               - 정수와 실수 연산 = 실수형 타입 (double)
               - 정수와 정수 연산 = int 타입
               - 실수와 실수 연산 = double 타입
               - 큰 타입과 작은 타입 연산 = 큰 타입

               ※ 피연산자를 4byte 단위로 저장하기 때문에,
                  4byte보다 작은 타입 (byte, char, short)는 int로 변환되어 연산 수행

                  7 + 5 
                  → 7, 5  : 피연산자 (연산에 참여하는 변수나 값을 피연산자라고 칭함)
                  → +  : 연산자 (산술연산자 +,-,* 기호와 같이, 이미 정의된 연산을 수행하는 기호나 키워드 의미)
             ____________________________________________________________________________

            ex) 
            int A = 10;
            double B = 5.5;
            double C = A + B; // C에 15.5 저장됨
                                 ▷ A는 double 형으로 자동 타입 변환된다.

            int A = 10;
            double B = 5.5;
            int C = A + (int)B; // C에 15가 저장됨 (소수점 버려짐)
            
         --------------------------------------------------------------------------------------------------

         < 기본값 > 
           ● boolean : false
           ● char : '\u0000' >> 유니코드로 null
           ● byte, short, int : 0
           ● long : 0L
           ● float : 0.0f
           ● double : 0.0d 또는 0.0

  
           float pi;  >> 그래야 메모리를 작게 잡아먹으니 (메모리 효율)
           pi = 3.14f;  >> f라는 접미사를 붙혀준다. (float)
           float average = 0f; >> 형맞추기 f

           float : 1.4E-45 ~ 3.4E38
           double : 4.9E-324 ~ 1.8E308
           E=Exponent
           ▶ 정수 리터럴에 10의 지수를 나타내는 e또는 E가 포함되어 있으면,
              실수 타입 변수 (float, double)에 저장해야 한다.

              double var3 = 3e6 ▷ 3000000
              double var4 = 2e-3 ▷ 0.002

           0 0000000 = 0
           1 1111111 = 127 (2의 7승 = 128)
           -128 ~ 127까지 담을 수 있다.

           학생1 : 92
           학생2 : 100
           학생3 : 72
           int score1, score2, score3;
           byte score1, score2, score3;

           char : 0 ~ 65535(2의 16승) 

___________________________________________________________________________________________________________________


  ▶ 참조형(reference type) 
     : 4byte
     : 기본형을 제외한 나머지 모든 타입. (즉 포인터가 된다.)
       ▷ 클래스 타입 (보통 첫글자가 대문자 ▶ ex)String)
       ▷ 배열 타입


       < 기본값 > 
         ● 참조형 : null


       ex) String str = "abc def";
           str이라는 박스공간이 있는데, 다른 박스에 abc def가 담겨있는데, 그걸 str이 가르키고 있다.

           int[] arr;  >> 배열
           int[] score = new int[10];


___________________________________________________________________________________________________________________


[ 데이터 타입 분류 ]

   · 기본 타입 : 정수, 실수, 문자, 논리 리터럴을 저장하는 타입 (실제 값 저장)
                 - 정수 타입 : byte, short, char, int, long
                 - 실수 타입 : float, double
                 - 논리 타입 : boolean

   · 참조 타입 : 객체(Object)의 번지를 참조(저장)하는 타입 (메모리 번지값을 통해 객체를 참조한다.)
                 - 문자열, 배열, 열거, 클래스, 인터페이스


   ex)

   // 기본 타입 변수
   int age = 25;
   double price = 100.5;

   // 참조 타입 변수
   String name = "케피";
   String hobby = "영화";


   ▶ 변수는 스택(Stack) 영역에 생성, 
      객체는 힙(Heap) 영역에 생성된다.
      
      ──────────────────────────────────────────────────────────────
      │           스택 영역           │           힙 영역           │
      ──────────────────────────────────────────────────────────────
      │           age : 25           │                             │
      │         price : 100.5        │                             │
      │         name : 15번지         │        15번지 : "케피"      │
      │         hobby : 254번지       │        254번지 : "영화"     │
      ──────────────────────────────────────────────────────────────
      ▶ 기본 타입 변수인 age와 price는 값을 직접 저장하고 있지만,
         참조 타입 변수(String 클래스)인 name과 hobby는 힙 영역의 String 객체의 주소 값을 가진다.

    ---------------------------------------------------------------------------------------------------

    [ String 변수 선언 및 문자열 객체 참조 ]
      : String 타입 변수는 문자열 객체를 참조한다. 
        (문자열은 String 객체로 생성, 변수는 String 객체를 참조한다.)

      ▶▶ String 변수이름 = "문자열"

      ▶ 문자열 리터럴이 동일하다면, 동일한 String 객체를 공유하도록 되어있다.

          ex)
          String name1 = "케피";
          String name2 = "케피";

        ──────────────────────────────────────────────────────────────
        │           스택 영역           │           힙 영역           │
        ──────────────────────────────────────────────────────────────
        │        name1 : 224번지        │      224번지 : "케피"       │
        │        name2 : 224번지        │                            │
        ──────────────────────────────────────────────────────────────
        ▷ 비교연산시 결과!
           동일한 문자열 리터럴로 String 객체를 생성한 경우 == 연산시 true!

      ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

      ▶ new 연산자를 사용해서 직접 String 객체를 생성할 수 있다. (서로 다른 객체)
         (new 연산자는 힙 영역에 새로운 객체를 만드는 객체 생성 연산자)

          ex)
          String name1 = new String("케피");
          String name2 = new String("케피");

        ──────────────────────────────────────────────────────────────
        │           스택 영역           │           힙 영역           │
        ──────────────────────────────────────────────────────────────
        │        name1 : 254번지        │      254번지 : "케피"       │
        │        name2 : 256번지        │      256번지 : "케피"       │
        ──────────────────────────────────────────────────────────────
        ※ 서로 다른 객체 참조!

        ▷ 비교연산시 결과!
           new 연산자로 String 객체를 생성한 경우 == 연산시 false!

           ex) 
           String name1 = "케피";
           String name2 = "케피";
           String name3 = new String("케피");

           name1 == name2;  // true
           name1 == name3;  // false


        ▶ 문자열만 비교할때는 equals() 메소드를 사용한다.
        ▶▶ boolean result = str1.equals(str2);
             ▷ str1 : 원본 문자열
             ▷ str2 : 비교 문자열

      ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

      ▶ String 변수는 "참조 타입" 이므로 null 로 초기화가 가능하다.
      ▶▶ String hobby = null;

      문자열로 초기화 이후, 더 이상 String 객체를 참조하지 않도록 할 수 있다.

        ex) 
        String hobby = "여행";
        String hobby = null;

        ▶ 참조를 잃은 String 객체는 JVM에서 쓰레기 객체로 취급되어 가비지 컬렉터에 의해 자동제거 된다.

___________________________________________________________________________________________________________________


printf() 함수 : 문자열을 출력하는 함수.
f : format

<format text, 서식문자 >
%d(Decimal) : 10진 정수
%X(heXa-) : 16진수
%f(float) : 실수형
%c(Character) : 문자
%s(String) : 문자열

_________________________________________________________________________

입력함수 : nextLine(), nextlnt(), nextDouble() ...

System.out.println()

Scanner.nextlnt() XXXXXXXXXXXXXX 안됨!!!



import java.util.Scanner;

Scanner 변수 = new Scanner(System.in); >> 참조형
String str = 변수.nextLine(); >> 참조형
int num = 변수.nextlnt(); >> 기본형

